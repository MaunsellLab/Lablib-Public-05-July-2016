/****************** FUNCTION DESCRIPTION ********************USAGE	q_updateCond (qc, intensity, response)ARGUMENTS	qc	condition	intensity	intensity at which trial is presented	response	0...qc->nResponses-1 are legal observer responses.				-1 if no trial occurred, to initialize the condition.SUMMARY	Updates the QUEST tables for the specified condition given theparameters (intensity,response) of a trial. Except that a responseof -1 indicates that no trial occurred, and requests initialization.	If a trial did occur, then divides out the initial probabilities from the likelihood function if the number of initial trials has been exceeded for the specified condition.	Computes now.pTotal, the total of the p array, and pLatestResponse, theratio of now.pTotal to its previous value prior.pTotal.	q_updateCond is the only routine that modifies the p array.RETURN VALUE	Returns -1 if intensity is out of the range of the QUEST tables, inwhich case data for that trial is not recorded. To avoid this error,the experimental program should only present stimuli within the rangedefined by the call to q_makeCond(). Values returned by q_mode() areguaranteed to be within range. (This is true of all of the Bayesianthreshold estimates, not just q_mode().)	Returns 0 if successful.HISTORY9/85		Version 1, A. B. Watson and K. Baldwin10/16/86	Version 2, A. Fitzhugh6/25/87		AF: Added error checking for level out of range.11/6/87		FW: receive (QCondition *)qc instead of cond;				use double vars everywhere;12/5/87		DGP: added test for response==-1, moved q_setPrior() to here			from q_InitialGaussian().12/15/87	DGP: moved table initialization to here from q_makeCond().			Moved all important loops to subroutines using registers.8/31/91		dgp. Many minor changes in order to support new responses array.9/2/91		dgp	q_setPrior now loads now.pTotal and initial.entropy.			After each trial, copy now.entropy to prior.entropy.12/4/91	dgp	Eliminated some redundant error fprintf's in q_updateCond().8/19/94	dhb, ccc	Tried to improve printfs for MATLAB by casting.			Included "VideoToolbox.h" if MATLAB is defined.8/31/94	dhb & dgp changed fprintf(stderr,...) to printf(...) for compatibility 			with MATLAB.11/3/94 dgp Debbie Moore reported that Quest's threshold estimates became NAN			somewhere between 1000 and 2000 trials. This turned out to be due to			underflow of the posterior pdf qc->p. On each trial it got multiplied			by the likelihood function that is less than 1, and was never renormalized.			I now renormalize it if qc->now.pTotal gets out of the range [1e-6,1e6].			It's now still running happily at 100,000 trials, and would probably go			much further, but I terminated the test.*************************************************************/#if MATLAB	#include "VideoToolbox.h"#endif#include <stdio.h>#include "q_include.h"void _UpdateCond(QCondition *qc,int index,int response);#if THINK_C	#pragma options(global_optimizer,gopt_induction,gopt_cse,gopt_loop,gopt_coloring)	#pragma options(defer_adjust,redundant_loads,assign_registers,honor_register)#endifint q_updateCond(register QCondition *qc,double intensity,int response){	int i,r;	int nLevels=qc->nLevels;		if (response>=qc->nResponses||response<-1) {		printf("q_updateCond: response %ld not in domain [%ld,%ld]\n"			,(long)response,-1L,qc->nResponses-1L);		return -1;	}	qc->prior=qc->now;	qc->now.entropy=NAN;	/* expensive, compute it only if you need it */	qc->now.variance=NAN;	/* expensive, compute it only if you need it */	if (response>=0) {		/* check to make sure the intensity is within the grid */		i=vtoi(qc,intensity);		if (i<0 || i>=nLevels) {			#if !MATLAB				printf("q_updateCond: i=%ld: "					"intensity %.2f out of range [%.2f,%.2f] \n"					,(long)i,intensity,itov(qc,0),itov(qc,nLevels-1));			#else				printf("q_updateCond: i=%ld: "					"intensity %.2lf out of range [%.2lf,%.2lf] \n"					,(long) i,(PRINTF_DOUBLE) intensity,					(PRINTF_DOUBLE) itov(qc,0),					(PRINTF_DOUBLE) itov(qc,nLevels-1));/*NOTE: This printf for MATLAB hasn't been tested. David Brainard thinks it'llwork with both MATLAB 3 and 4. Denis is concerned that the cast to PRINTF_DOUBLEmight not be effective--that a subroutine call might be required to obtain therequired size of double--and that even then there would be a question as toexactly what the compiler would promote the argument tobefore passing it. Neither David nor Denis recalls exactly what MPWprintf expects to receive when one specifies %lf.*/			#endif			return(-1);		}		qc->responses[response][i]++;		qc->trials[i]++;		qc->trialsTotal++;		_UpdateCond(qc,i,response);		if (qc->nInitial==qc->trialsTotal)			q_removePrior(qc);	} else {		/* initialize all writable tables */		for (i=0; i<nLevels; i++) {			for (r=0; r<qc->nResponses; r++)				qc->responses[r][i]=0;			qc->trials[i]=0;		}		qc->trialsTotal=0;		q_setPrior(qc);	}	qc->now.pTotal=q_total(qc);	if (response>=0){		qc->pLatestResponse=qc->now.pTotal/qc->prior.pTotal;		if(qc->now.pTotal>0 && (qc->now.pTotal<1e-6 || qc->now.pTotal>1e6)){			// prevent underflow due to cumulating many trials			register double norm=1.0/qc->now.pTotal;			for(i=qc->nLevels-1;i>=0;i--)qc->p[i]*=norm;			qc->now.pTotal=1.0;		}	}else{		/* PEST needs these at first trial. EJC */		qc->Presponse=-1;		qc->Pintensity=0.0;	}	return(0);}/*************************************************************************If response r occurred at level L and we consider each threshold level T, then theupdate formula isp[ltoi(T)] *= pResponse[r][ltoii(L-T)];	Define i=ltoi(T), so T=itol(i)	Define index = ltoi(L), so L=itol(index)p[i] *= pResponse[r][ltoii(itol(index) - itol(i))];	Since itol and ltoii both have a gain of 1, this simplifies top[i] *= pResponse[r][ltoii(index) - i];	dgp 12/16/87, 8/30/91**************************************************************************//* update p after response r */void _UpdateCond(register QCondition *qc,int index,int r){	register int i,ii;		ii=ltoii(qc,index);	for(i=qc->nLevels-1;i>=0;i--)		qc->p[i]*=qc->pResponse[r][ii-i];}void q_setPrior(QCondition *qc){	register int i;	register double *pInitial,*p;		pInitial=qc->pInitial;	p=qc->p;	for(i=qc->nLevels-1;i>=0;i--)*p++=*pInitial++;	qc->now.pTotal=q_total(qc);	qc->now.entropy=q_entropy(qc);	qc->now.variance=q_variance(qc);	qc->initial=qc->prior=qc->now;}void q_removePrior(QCondition *qc){	register int i;	register double *pInitial,*p;		pInitial=qc->pInitial;	p=qc->p;	for(i=qc->nLevels-1;i>=0;i--)*p++/=*pInitial++;}/* Returns the sum of the values in the p table.*/double q_total(QCondition *qc){	register int i;	register double *p,total;		p=qc->p;	total=0.0;	for(i=qc->nLevels-1;i>=0;i--)total+=*p++;	return total;}