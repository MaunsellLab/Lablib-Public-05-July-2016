/*QuestOpen.cA high-level user-callable routine to allocate and initialize all the Quest arrays.Call this before you measure threshold. When you're done, call QuestClose()to free the space.Setting q->fakeIt to true (any nonzero value) requests that q->actualThreshold[]be filled by calls from QuestGetSample(). QuestGetSample() returns a random sample from the probability distribution function defined by each condition's p table. The actualThreshold value is used only by QuestSimulateObserver(), QuestPrint and QuestPlot,and the low-level routines q_print and q_plot.q->epsilon is set automatically, to minimize the sweat factor, if the supplied value is a Nan.q->quantile is set automatically, to the best value, if the supplied value is a Nan.HISTORY:6/9/90	dgp	 wrote it.8/31/91	dgp	tidied up.12/17/91 dgp compute best value for q->quantile only if it's set to NAN.4/23/92	dgp	compute best value for q->epsilon only if it's set to NAN.12/8/92	dgp	Only initialize actualThreshold with sample from prior if			fakeIt is true.8/31/94	dhb & dgp changed fprintf(stderr,...) to printf(...) for compatibility with MATLAB.*/#include "Quest.h"#include <stdlib.h>void QuestOpen(Quest *q){	int cond;		q->nInitial=-1;	// Instruct that pInitial NEVER be divided out.	//	if(q->function!=NULL && IsNan(q->epsilon))	if(q->function!=NULL && isnan(q->epsilon))					// JHRM 080904		q->epsilon=q_minSweatFactor(q->function,q->beta,q->gamma,q->delta,0.0);	if(q->nConds<1 || q->nConds>CONDITIONS){		printf("QuestOpen: nConds==%ld not in range [1,%ld]\n\007"			,(long)q->nConds,(long)CONDITIONS);		exit(1);	}	if(q->nResponses<2 || q->nResponses>RESPONSES){		printf("QuestOpen: nResponses==%ld not in range [2,%ld]\n\007"			,(long)q->nResponses,(long)RESPONSES);		exit(1);	}	/* Allocate the conditions. Share pResponse and pInitial tables */	for(cond=0; cond<q->nConds; cond++) {		q->qConds[cond]=NULL;		q_makeCond(&q->qConds[cond],q->qConds[0],q->nResponses,q->nLevels,q->grain,				   q->guess[cond],q->nInitial);	}	/* Load pResponse & pInitial tables. */	q_response(q->qConds[0],q->function,q->beta,q->gamma,q->delta,q->epsilon);	q_InitialGaussian(q->qConds[0],q->initialSD);	for(cond=0; cond<q->nConds; cond++) {		q_updateCond(q->qConds[cond],0.0,-1);	/* initialize */		q->thresholdEstimate[cond]=NAN;		if(q->fakeIt)q->actualThreshold[cond]=QuestGetSample(q,cond);		else q->actualThreshold[cond]=NAN;	}//	if(IsNan(q->quantileOrder))q->quantileOrder=q_bestQuantileOrder(q->qConds[0]);	if (isnan(q->quantileOrder)) {		q->quantileOrder = q_bestQuantileOrder(q->qConds[0]);	}}