/*Ideal.c, based on QuestExample.cThis illustrates the use of the Quest package. The key point is that even thoughall the hard work is done by the myriad routines whose names begin with "q_...",the user of the package can ignore them, and just use the "Quest..." routines,which are in three files: Quest.c, QuestOpen.c, and QuestClose.c.To convert this program into one that measures the thresholds of a real observeryou need to set q->fakeIt to zero (false) and you need to replace the call toQuestSimulateObserver() by your own subroutine that does a trial at (or near) thespecified intensity and condition and returns the observer's response. That'sit!You can randomly interleave the trials if you want to. The only rule is thatthere are three steps to running each trial. First ask QuestQuantile() torecommend a testIntensity. Then run the trial, preferably at a test intensityclose to that recommended. (I suggest you pass a pointer to testIntensity in thecall to your routine, so that your routine can set it to the value actuallyused.) Then call QuestUpdate() to record the results of that trial: the responseand actual testIntensity used. Run trials as long as you want. When you're done, call QuestMean() to get athreshold estimate, once for each condition.There are two upper bounds on the parameters that you set here. The maximum number ofconditions is set by CONDITIONS in Quest.h. As of this writing it is set to 85, butyou can change it. The maximum number of distinct responses is set by RESPONSESin q_include.h and is presently set to 5. It too can be changed. Most users willhave only a few conditions and only two responses, but leaving the maximum boundsmuch higher doesn't waste much space.HISTORY:4/23/92	dgp	wrote it.*/#include <stdio.h>#include <stdlib.h>#include <math.h>#include <memory.h>#include <time.h>#include <assert.h>#include "q_include.h"#include "Quest.h"void Experiment(Quest *q);void main(void){	Quest *q;	int i;	char string[64];	double thresholdCriterion;	q=(Quest *)malloc(sizeof(Quest));	assert(q!=NULL);//	q->seed=1;		// A fixed seed for the random number generator.	time(&q->seed);	// An unpredictable seed for the random number generator.	srand(q->seed);	q->nConds=1;	// The number of conditions for this experiment.	q->grain=0.05;	// The grain (smallest step) of the test intensity.	q->nLevels=200;	// Number of possible testing intensities	q->nTrials=20;	q->initialSD=2.0;	// initial standard deviation of the threshold intensity.	q->nResponses=2;	q->quantileOrder=NAN;	// request that it be initialized by QuestOpen()	q->fakeIt=1;			// Simulate the observer's responses	q->function=WeibullPResponse;	q->beta=3.5;			// Parameters for 2AFC psychometric function	q->gamma=0.5;	q->delta=0.01;	q->epsilon=0;	thresholdCriterion=0.82;	q_findIntensity(thresholdCriterion,q->function		,1,&q->epsilon,q->beta,q->gamma,q->delta,0);	for(i=0;i<q->nConds;i++){		q->guess[i]=0.0;		printf("Enter guess intensity for condition #%d:",i);		gets(string);		sscanf(string,"%lf",&q->guess[i]);		printf("%lf\n",q->guess[i]);	}	Experiment(q);	free(q);}void Experiment(Quest *q){	int response;			// Observer's response to stimulus: 0...q->nResponses-1	int cond;				// The current condition.	int trial;				// The current trial.	double testIntensity;	// Intensity at which the observer is tested.	double bestIntensity,minECost;	long n=1;				// number of trials to look ahead	QuestOpen(q);	for(trial=0;trial<q->nTrials;trial++){		for(cond=0;cond<q->nConds;cond++){			testIntensity=QuestQuantile(q,cond);			// printf("before %ld;",FreeMem());			minECost = q_minECostN(q->qConds[cond],q_variance,&bestIntensity,n);			// printf("after %ld;",FreeMem());			testIntensity=bestIntensity;			response=QuestSimulateObserver(q,cond,testIntensity);			QuestUpdate(q,cond,testIntensity,response);			QuestPlot(q,cond,testIntensity,response);	// optional		}		}	for(cond=0;cond<q->nConds;++cond){		q->thresholdEstimate[cond]=QuestMean(q,cond);		QuestPrint(stdout,q,cond);						// optional	}	QuestClose(q);}