/******************* FUNCTION DESCRIPTION *********************USAGE		double	*array;		int elements;			elements=10;		array= (double *)q_erralloc("MyRoutine",elements*sizeof(double));		...		free(array);		ARGUMENTS	s 	-	string holding name of calling routine	n	-	number of bytes to be allocated	SUMMARY	Uses the standard C routine calloc() to dynamically allocate	and zero a block of memory n-bytes big. If an error develops,	i.e. the pointer returned by calloc() is NULL, prints a message	to stderr pointing out that the routine described by string s	developed an error while allocating memory then exit the program.	RETURN VALUE	Return a pointer to the allocated memory block. 	ERROR HANDLING	If calloc() returns a NULL pointer, exit the program after printing	an error message to stderr.	REVISION HISTORY11/16/87	FW: add second argument to q_erralloc() and put in 			separate file12/25/91 dgp added # of bytes to error message3/5/94	dgp	tidied up.9/1/94	dgp changed calloc(n,1) to calloc(1,n), which seems more appropriate, 			and more likely to result in good alignment for speed, but			probably makes no difference.9/1/94	dgp made first argument "const" indicating that the string won't be			modified.********************************************************** */#include <stdio.h>#include <stdlib.h>#include "q_include.h"char *q_erralloc(const char *s,unsigned long n){	char *ptr;		ptr=calloc(1,n);	if(ptr==NULL){		printf("q_erralloc() couldn't allocate %lu bytes for %s\n\007",n,s);		exit(1);	}	return ptr;}