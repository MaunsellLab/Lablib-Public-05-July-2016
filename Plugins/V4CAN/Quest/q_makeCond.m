/*************** NASA->Ames->Perception & Cognition Group ***************USAGE	q_makeCond(&qc, qc0, nLevels, grain, guess, nInitial)ARGUMENTS	QCondition 	*qc		condition to be created (if necessary) & initialized	QCondition 	*qc0		optional condition which has already filled							its pInitial and pResponse arrays.							Otherwise NULL.	int 		nLevels		number of possible levels for this condition	double 		grain		distance between levels	double 		guess		initial estimate of threshold	int 		nInitial	number of trials to use pInitialSUMMARY	Initializes all the QUEST tables and variables for a given condition.	If this is the first condition to be initialized, then	the calling program should allocate and load the psychometric	tables (using q_psych() & q_InitialGaussian() ) after. 	calling q_makeCond(). Subsequent conditions being initialized 	may then share these psychometric functions by passing in 	qc0 a pointer to that first condition.	If nLevels is different for any condition then new 	psychometric functions must be allocated and loaded. 	In this case, if qc0 is not NULL an error message	will be generated and the program will be aborted.	EXAMPLES	QCondition *qConds[MAXCONDS];	double grain,guess;	int nLevels,nInitial;	q_makeCond(&qConds[0],NULL, 20, 1.0, 4.20, 20);	q_psych(qConds[0], &q_Weibull, BETA, GAMMA, DELTA, EPSILON);	q_InitialGaussian(qConds[0],sd);		for(i=1; i<nConds; i++)			q_makeCond(&qConds[i],qConds[0], nLevels, 20, 1.0, 4.20, 20);ERROR HANDLING & LIMITATIONS	Program will exit if there is insufficient memory. q_makeCond()	will reject an attempt to initialize a condition sharing 	psychometric tables with another condition of different nLevels.COMMENTS	You may re-initialize an existing condition.HISTORY10/86		Version 2, A. Fitzhugh11/6/87		FW: use double vars everywhere; pass 			(QCondition *) qc to other routines;11/13/87	FW: share psychometric tables when possible; do			not initialize psychometric tables in q_makeCond();12/15/87	DGP: moved code that initialized the arrays over to			q_updateCond(), to be activated when response=-1.8/31/91		dgp. Everything is now allocated if it hasn't been already.8/31/94	dhb & dgp changed fprintf(stderr,...) to printf(...) for compatibility with MATLAB.*****************************************************************************/#include <stdio.h>#include <stdlib.h>#include "q_include.h"void q_makeCond(QCondition **qcPtr,QCondition *qc0	,int nResponses,int nLevels,double grain,double guess,int nInitial){	QCondition *qc;	int i,r;	static const char here[]="q_makeCond";		if(nResponses<2 || nResponses>RESPONSES){		printf("q_makeCond: nResponses==%ld not in range [2,%ld]\n\007"			,(long)nResponses,(long)RESPONSES);		exit(1);	}	qc=*qcPtr;	/* If necessary, allocate condition */	if(qc==NULL) {		qc=*qcPtr=(QCondition *) q_erralloc(here,sizeof(QCondition));		/* This zeroing is redundant, since q_erralloc calls calloc. */		qc->pInitial=NULL;		qc->p=NULL;		for(r=0; r<RESPONSES; r++){			qc->pResponse[r]=NULL;			qc->responses[r]=NULL;		}		qc->trials=NULL;	}	qc->nLevels=nLevels;	qc->nnLevels=nLevels*2-1;	qc->grain=grain;	qc->guess=guess;	qc->trialsTotal=0;	qc->nInitial=nInitial;	qc->nResponses=nResponses;	/* If requested, share the read-only tables */	if(qc0!=NULL) {		if(nResponses!=qc0->nResponses) {			printf("q_makeCond: nResponses don't match: %ld!=%ld\n\007"				,(long)nResponses,(long)qc0->nResponses);			exit(1);		}		if(nLevels!=qc0->nLevels) {			printf("q_makeCond: nLevels don't match: %ld!=%ld\n\007"				,(long)nLevels,(long)qc0->nLevels);			exit(1);		}		qc->pInitial=qc0->pInitial;		for(r=0; r<qc->nResponses; r++) qc->pResponse[r]=qc0->pResponse[r];	}	/* Allocate the remaining tables */	if(qc->pInitial==NULL) qc->pInitial=(double *) q_erralloc(here,sizeof(double)*nLevels);	if(qc->p==NULL) qc->p=(double *) q_erralloc(here,sizeof(double)*nLevels);	if(qc->H==NULL) qc->H=(double *) q_erralloc(here,sizeof(double)*nLevels);	if(qc->likelihood==NULL) qc->likelihood=(double *) q_erralloc(here,sizeof(double)*nLevels);	if(qc->pSum==NULL) qc->pSum=(double *) q_erralloc(here,sizeof(double)*nLevels);	if(qc->trials==NULL) qc->trials=(int *) q_erralloc(here,sizeof(int)*nLevels);	for(i=0; i<qc->nLevels; i++) qc->trials[i]=0;	for(r=0; r<qc->nResponses; r++){		if(qc->pResponse[r]==NULL)			qc->pResponse[r]=(double *) q_erralloc(here,sizeof(double)*qc->nnLevels);		if(qc->responses[r]==NULL)			qc->responses[r]=(int *) q_erralloc(here,sizeof(int)*nLevels);		for(i=0; i<qc->nLevels; i++)			qc->responses[r][i]=0;	}}