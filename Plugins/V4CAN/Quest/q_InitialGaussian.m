/****************** FUNCTION DESCRIPTION ********************USAGE	q_InitialGaussian (qc, sd);ARGUMENTS	QCondition	*qc		pointer to a condition 	double		sd			standard deviation of GaussianSUMMARY	Loads the array qc->pInitial with a Gaussian 	distribution with a standard deviation of 'sd'. 	If qc->pInitial is NULL, then memory is	allocated, otherwise the existing array is used.RETURN VALUE	none.ERROR HANDLING & BOUNDARY CONDITIONS	Exits if not enough memory to create the function.COMMENTS	Note, the Gaussian NOT normalized to unit area, because it's unnecessary	in this application.REVISION HISTORY	9/85		Version 1, A. B. Watson and K. Baldwin	10/16/86	Version 2, A. Fitzhugh	11/6/87		FW: use double vars everywhere; 				receive (QCondition *) qc; allocate memory if required;	11/16/87	FW: rename fcn; do not pass nLevels; unconditionally				call setInitial(); do not return ptr	12/4/87		FW: use intensities when computing initial pdf; correct 				mistake of using exp10() instead of exp() when  				computing points of initial pdf; correct 				old problem of not scaling exponent by 1/2. 	12/5/87		DGP: cosmetic changes and moved q_setPrior() to q_updateCond(). 	12/15/87	DGP: made q_Gaussian() a separate routine in this file. 	12/16/87	DGP: removed call to q_updateCond(qc,0.0,-1). 	8/31/91		dgp	tidied up.	12/19/91 dgp Added q_Gaussian()	1/5/92		dgp: added code to handle zero sd without producing infinite probability.*********************************************************/#include <stdio.h>#include "q_include.h"double _Gaussian(double y,double sd);#if THINK_C && GENERATING68881	#define exp _exp	/* use fast 68881 instruction instead of SANE */	#define log _log	/* use fast 68881 instruction instead of SANE */#endifvoid q_Gaussian(QCondition *qc,double sd){	register int i;		if(sd>0.0)for (i=0; i<qc->nLevels; i++)		qc->p[i]=_Gaussian(itov(qc,i)-qc->guess,sd);	else{	// Special case of zero standard deviation		for (i=0; i<qc->nLevels; i++)qc->p[i]=0.0;		qc->p[ltoi(qc,0)]=1.0;	}		}void q_InitialGaussian(QCondition *qc,double sd){	register int i;		if (qc->pInitial==NULL)		qc->pInitial=			(double *)q_erralloc("q_InitialGaussian",sizeof(double)*qc->nLevels);	if(sd>0.0)for (i=0; i<qc->nLevels; i++)		qc->pInitial[i]=_Gaussian(itov(qc,i)-qc->guess,sd);	else{	// Special case of zero standard deviation		for (i=0; i<qc->nLevels; i++)qc->pInitial[i]=0.0;		qc->pInitial[ltoi(qc,0)]=1.0;	}		}/* Note, this is NOT normalized to unit area, because it's unnecessaryin this application */double _Gaussian(double y,double sd){	y/=sd;	return exp(-0.5*y*y);}