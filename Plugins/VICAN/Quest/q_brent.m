/************************************************************************USAGE	double x_min,y_min;	double ax,bx,cx;	double tolerance;	double f(x);		y_min = q_brent(ax,bx,cx,&f,tolerance,&x_min);ARGUMENTS	ax,bx,cx - abscissas of the function f(x) to be minimized. The	only requirement on these are that	1) ax and cx bracket the minimum	2) f(bx) is less than both f(ax) and f(cx).		f - The address of the function to be minimized. The function must	look parabolic near the minimum.		tolerance - the precision to be used in finding the minimum of the	function.		x_min - the address of the variable where the abscissa of the	minimum gets stored. q_brent itself returns the minimum value of	the function; the abscissa gets returned here.SUMMARY	q_brent uses parabolic interpolation to find very quickly the minimum	of the function f(x), as long as	1) ax and cx bracket the minimum	2) f(bx) is less than both f(ax) and f(cx).	3) the function x is locally parabolic near the minimum.RETURN VALUE	Returns a double precision floating point value.	COMMENTS	See "Numerical Recipes, The Art of Scientific Computing", Press,	Flannery, Teukolsky, and Vetterling. Cambridge University Press,	1986, pp. 283-286.	HISTORY12/6/87		DGP12/20/87	Commented and cleaned up a little. EJ Chichilnisky8/10/94		dgp added prototype8/31/94	dhb & dgp changed fprintf(stderr,...) to printf(...) for compatibility with MATLAB.************************************************************************/#include <stdio.h>#include <stdlib.h>#include "q_include.h"#define ITMAX 100#define CGOLD 0.3819660#define ZEPS 1.0e-10#define SIGN(a,b) ((b) > 0.0 ? fabs(a) : -fabs(a))#define SHFT(a,b,c,d) (a)=(b);(b)=(c);(c)=(d);double q_brent(double ax,double bx,double cx,double (*f)(double),double tol,double *xmin);double q_brent(double ax,double bx,double cx,double (*f)(double),double tol,double *xmin){	int iter;	double a,b,d,etemp,fu,fv,fw,fx,p,q,r,tol1,tol2,u,v,w,x,xm;	double e=0.0;	void nrerror();		a=((ax<cx)?ax : cx);	b=((ax>cx)?ax : cx);	x=w=v=bx;	fw=fv=fx=(*f)(x);	for (iter=1; iter<=ITMAX; iter++) {		xm=0.5*(a+b);		tol2=2.0*(tol1=tol*fabs(x)+ZEPS);		if (fabs(x-xm)<=(tol2-0.5*(b-a))) {			*xmin=x;			return fx;		}		if (fabs(e)>tol1) {			r=(x-w)*(fx-fv);			q=(x-v)*(fx-fw);			p=(x-v)*q-(x-w)*r;			q=2.0*(q-r);			if (q>0.0)				p=-p;			q=fabs(q);			etemp=e;			e=d;			if (fabs(p)>=fabs(0.5*q*etemp)||p<=q*(a-x)||p>=q*(b-x))				d=CGOLD*(e=(x>=xm?a-x : b-x));			else {				d=p/q;				u=x+d;				if (u-a<tol2||b-u<tol2)					d=SIGN(tol1,xm-x);			}		} else {			d=CGOLD*(e=(x>=xm?a-x : b-x));		}		u=(fabs(d)>=tol1?x+d : x+SIGN(tol1,d));		fu=(*f)(u);		if (fu<=fx) {			if (u>=x)				a=x;			else				b=x;			SHFT(v,w,x,u)			SHFT(fv,fw,fx,fu)		} else {			if (u<x)				a=u;			else				b=u;			if (fu<=fw||w==x) {				v=w;				w=u;				fv=fw;				fw=fu;			} else if (fu<=fv||v==x||v==w) {				v=u;				fv=fu;			}		}	}	printf("q_brent: too many iterations\n");	printf("...now exiting to system...\n");	exit(1);	*xmin=x;	return fx;}#undef ITMAX#undef CGOLD#undef ZEPS#undef SIGN