/****************** FUNCTION DESCRIPTION ********************USAGE	double minECost,bestIntensity;		minECost = q_minECostN(qc, cost, &bestIntensity, n)ARGUMENTS	qc			pointer to a condition		cost	address of the cost function, i.e. q_entropy or q_variance		bestIntensity	a double that will be set to					the ideal testing intensity, i.e. the one that yields minimum					expected cost after n trials		n				number of trials to look aheadSUMMARY	The function works recursively, looking ahead n trials and calculating	the intensity for the next trial that will yield the minimum expected cost	after n trials.RETURN VALUE	Returns a double that is the minimum cost. Also,	*bestIntensity gets set to the testing intensity that yields that expected	cost after n trials.ERROR HANDLING & BOUNDARY CONDITIONS	No particular error handling is built in.COMMENTS	The function works recursively in a subtle way. The user calls	q_minECostN(), passing it the number of trials to look ahead.	This function in turn calls q_brentMin(), an adaptation of the	general purpose minimization routine q_brent() (see q_brent.c),	which finds the minimum of the expected cost function q_ECostN().		This expected-cost function is tricky: it returns the following:	The expected cost after n trials, provided the current trial is at the	given intensity, and the subsequent n-1 trials are at the optimal	intensities. So q_ECostN() in turn calls q_minECostN() twice,	once for each possible response, asking it to look ahead (n-1) trials.		Schematically, the recursive calling sequence looks like this:		main() ->	q_minECostN( n )->	q_brentMin( n )->	q_ECostN( n )->	q_minECostN( n - 1 )->	q_brentMin( n - 1 ) etc.		At n = 0, q_minECost() simply returns the cost at the current trial,	so recursion comes to an end.REVISION HISTORY	12/22/87	EJ Chichilnisky & DGP	8/28/91		dgp	Added prototype for cost() and f() arguments	9/1/91		dgp	 only sum cost when pLatestResponse>0*************************************************************/#include <math.h>#include <stdio.h>#include <stdlib.h>#include "q_include.h"double q_minECostN(QCondition *qc,double (*cost)(QCondition *qc)	,double *bestIntensity,int n)/* n is the number of trials to look ahead */{	double minECostN;	QCondition *qcTemp;	double ax,bx,cx;				/* bracketing abscissas for q_brentMin */	double tolerance;		if(n==0)return (*cost)(qc);		/* Allocate a temporary condition structure */	qcTemp=NULL;	q_makeCond(&qcTemp,qc		,qc->nResponses,qc->nLevels,qc->grain,qc->guess,qc->nInitial);		/* This tolerance for brentMin() is the largest possible that will	make brentMin() function correctly. EJC */	tolerance=qc->grain/4.0;		/* The bracketing abscissas for q_brentMin. See q_brent() in q_brent.c */	ax=itov(qc,0);	bx=q_quantile(qc,q_bestQuantileOrder(qc));	cx=itov(qc,qc->nLevels-1);		minECostN=q_brentMin(ax,bx,cx,q_ECostN,tolerance,bestIntensity,qc,qcTemp,						 cost,n);		q_freeCond(&qcTemp);		return(minECostN);}#define ITMAX 100#define CGOLD 0.3819660#define ZEPS 1.0e-10#define SIGN(a,b) ((b) > 0.0 ? fabs(a) : -fabs(a))#define SHFT(a,b,c,d) (a)=(b);(b)=(c);(c)=(d);/* Function q_brentMin().q_brentMin() returns the minimum of the function f() over therange [ax, bx]. The constraints are that1) The function f() must be locally parabolic near the minimum2) f(ax) > f(bx) and f(cx) > f(bx)3) bx lies between ax and cx.This function is adapted slightly from:"Numerical Recipes, The Art of Scientific Computing", Press,Flannery, Teukolsky, and Vetterling. Cambridge University Press,1986, pp. 283-286.Changes to the original are:1) Calling cost() with several parameters. cost()gets called at two spots in the routine.2) Including printfs at the end, which used to be a separate routine.*/double q_brentMin(double ax,double bx,double cx	,double (*f)(QCondition *qc,QCondition *qcTemp,double (*cost)(QCondition *qc),double *xmin,			int n,double x)	,double tol,double *xmin	,QCondition *qc,QCondition *qcTemp,double (*cost)(QCondition *qc),int n){	int iter;	double a,b,d,etemp,fu,fv,fw,fx,p,q,r,tol1,tol2,u,v,w,x,xm;	double e=0.0;		a=((ax<cx)?ax : cx);	b=((ax>cx)?ax : cx);	x=w=v=bx;		fw=fv=fx=(*f)(qc,qcTemp,cost,xmin,n,x);		for (iter=1; iter<=ITMAX; iter++) {		xm=0.5*(a+b);		tol2=2.0*(tol1=tol*fabs(x)+ZEPS);		if (fabs(x-xm)<=(tol2-0.5*(b-a))) {			*xmin=x;			return fx;		}		if (fabs(e)>tol1) {			r=(x-w)*(fx-fv);			q=(x-v)*(fx-fw);			p=(x-v)*q-(x-w)*r;			q=2.0*(q-r);			if (q>0.0)				p=-p;			q=fabs(q);			etemp=e;			e=d;			if (fabs(p)>=fabs(0.5*q*etemp)||p<=q*(a-x)||p>=q*(b-x))				d=CGOLD*(e=(x>=xm?a-x : b-x));			else {				d=p/q;				u=x+d;				if (u-a<tol2||b-u<tol2)					d=SIGN(tol1,xm-x);			}		} else {			d=CGOLD*(e=(x>=xm?a-x : b-x));		}		u=(fabs(d)>=tol1?x+d : x+SIGN(tol1,d));		fu=(*f)(qc,qcTemp,cost,xmin,n,u);		if (fu<=fx) {			if (u>=x)				a=x;			else				b=x;			SHFT(v,w,x,u)			SHFT(fv,fw,fx,fu)		} else {			if (u<x)				a=u;			else				b=u;			if (fu<=fw||w==x) {				v=w;				w=u;				fv=fw;				fw=fu;			} else if (fu<=fv||v==x||v==w) {				v=u;				fv=fu;			}		}	}	printf("Numerical Recipes run-time error...\n"		"Too many iterations in q_brentMin.\n"		"...now exiting to system...\n");	exit(1);		*xmin=x;	return fx;}/*q_ECostN() returns the expected cost of the next trial at the testingintensity, plus the minimum possible expected cost over the nextn-1 trials. See the comments above on the recursive nature of the code in this file.*/double q_ECostN(QCondition *qc,QCondition *qcTemp,double (*cost)(QCondition *qc),	double *bestIntensity,int n,double intensity){	double ECostN;	int r;		ECostN=0.0;	for (r=0; r<qc->nResponses; r++) {		q_copyCond(qc,qcTemp);		q_updateCond(qcTemp,intensity,r);		if(qcTemp->pLatestResponse>0.0)			ECostN+=q_minECostN(qcTemp,cost,bestIntensity,n-1)				*qcTemp->pLatestResponse;	}	return ECostN;}