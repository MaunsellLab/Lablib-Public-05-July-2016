/****************** FUNCTION DESCRIPTION ********************USAGE	double intensity;	intensity = q_quantile(qc,quantileOrder); ARGUMENTS	qc - Pointer to a condition	quantileOrderSUMMARY	Returns the intensity that is the desired quantile of p. You can obtain	a 95% confidence interval by calling it twice, with the indices 0.025 and 0.975.	RETURN VALUE	Returns a double, representing the intensity.ERROR HANDLING	Basically no error handling, in the interest of speed. If qc is messedup, you can expect this routine to bomb. If not, you can expect it to fly. Theone thing that gets checked is that the quantileOrder is between 0 and 1.HISTORY11/87 EJ Chichilnisky8/31/91	dgp	cosmetic changes12/8/91	dgp	"12/26/91 dgp Made it a bit faster.4/23/92	dgp	added comments above10/24/92 dgp renamed quantileIndex to quantileOrder for consistency with	rest of code.3/30/93	dgp return NAN if p[0] or pTotal are NAN.8/31/94	dhb & dgp changed fprintf(stderr,...) to printf(...) for compatibility with MATLAB.************************************************************************/#include <stdlib.h>#include <stdio.h>#include "q_include.h"#ifndef IsFinite	#define IsFinite(x) ((*(short *)&(x) & 32767)!=32767)	/* neither NAN nor ±INF */#endif#if THINK_C	#pragma options(global_optimizer,gopt_induction,gopt_cse,gopt_loop,gopt_coloring)	#pragma options(defer_adjust,redundant_loads,assign_registers,honor_register)#endifdouble q_quantile(QCondition *qc,double quantileOrder){	int i;	register double integral,*p;		if (!IsFinite(quantileOrder)||quantileOrder<0.0||quantileOrder>1.0) {		printf("q_quantile(): Quantile order %g is outside domain [0,1].\n"			,quantileOrder);		return NAN;	}	if(!IsFinite(qc->now.pTotal) || !IsFinite(qc->p[0]))return NAN;	integral=-quantileOrder*qc->now.pTotal;	p=qc->p;	while (integral<0.0) integral+=*p++;	p--;	i=p-qc->p;	/*		We know that integral is greater than or equal to zero. 		We now decide whether to return the last bin summed, or the one		before, to best approximate the specified quantileOrder.	*/	if (integral > *p - integral) i--;	return(itov(qc,i));}