/****************** FUNCTION DESCRIPTION ********************USAGE	response = q_getResponse(qc, actual, intensity);ARGUMENTS	qc	Condition pointer	actual	true threshold	intensity	the test intensity		 SUMMARY	Returns a response r, in the range 0 to qc->nResponses-1, with the	probabilities specified in the psychometric table pResponse[r].USAGE	p = q_Weibull(intensity - actual, beta, gamma, delta);	response = q_getBinomial(p);or	actual = q_getSample(qc);ARGUMENTS	qc	Condition pointer	actual	true threshold	intensity	the test intensityor	p		probability of correct response		 SUMMARY	Returns 1 with the probability specified by p. Otherwise returns 0.COMMENTS	To simulate an observer.REVISION HISTORY	11/86?	AF & ABW probably wrote it.	11/87	EJ Chichilnisky revised it slightly	12/6/87 DGP rewrote it to use the tabulated psychometric function instead			of evaluating a Weibull function (which was different from that used			to create pResponse). Separated the code into three routines:			q_getResponse, q_getBinomial, and q_WeibullOld.	12/21/87 DGP fixed intensity to ii conversion in q_getResponse().	12/22/87 Added q_getSample(). EJC	8/5/89	Put RAND_MAX in q_getBinomial(), to conform to ANSI C.	8/21/89	include stdlib.h instead of q_machine.h*************************************************************/#include <stdlib.h>#include "q_include.h"int q_getResponse(QCondition *qc,double actual,double intensity){	double p,pRemaining=1.0;	int ii,r;		ii=ltoii(qc,vtol(qc,intensity)-vtol(qc,actual));#if 1								/* old code, useful for replication check on rest of new code */	r=1;	p=qc->pResponse[r][ii];	if (q_getBinomial(p/pRemaining))		return r;	else		return 0;#endif	for (r=0; r<qc->nResponses; r++) {		p=qc->pResponse[r][ii];		if (q_getBinomial(p/pRemaining))			return r;		pRemaining-=p;		if (pRemaining<=0.0) {			printf("q_getResponse: pResponse doesn't sum to 1!\007\n");			exit(1);		}	}}/* returns a 1 with probability p, otherwise returns 0 */int q_getBinomial(double p){	double frand;		frand=rand()/(RAND_MAX+1.0);		/* rand # between 0.0 and 1.0 */	return(p>frand);}/* This function returns a random sample from the probability distributionfunction defined by the p table*/double q_getSample(QCondition *qc){	double quantileOrder,intensity;		quantileOrder=rand()/(RAND_MAX+1.0);	/* rand # between 0.0 and 1.0 */	intensity=q_quantile(qc,quantileOrder);	return(intensity);}