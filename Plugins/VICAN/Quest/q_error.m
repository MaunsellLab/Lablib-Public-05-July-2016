/****************** FUNCTION DESCRIPTION ********************USAGE	double value;	value = q_error(qc);SUMMARYCalculates the size of the 95% confidence interval about the threshold estimate. Other confidence limits can be accommodated bychanging the value of CRITERION.RETURN VALUEReturns the size of the confidence interval, or INF if the intervalis unbounded.COMMENTS  The size of the interval is determined by CRITERION. The confidence is the square of the cumulative normal distribution at CRITERION. This may be used to stop Quest when a desired confidence interval size is realized.  "bottom" is the highest index below the confidence interval. "top" is the lowest index above the confidence interval. Their difference is an estimate of the width of the confidence interval. Note that top>imax and bottom<imax, where imax is the mode. This is a conservative interval, on average one bin larger than  the true interval. That is why I subtract 1 from the returned width of the interval. REVISION HISTORY	9/85		Version 1, A. B. Watson and K. Baldwin	10/16/86	Version 2, A. Fitzhugh	11/6/87	FW: pass (QCondition *) qc instead of cond; use double vars.	12/4/87	DGP: convert to expect linear instead of log p array,	 	use itov() and vtoi(). Generally simplified the code	12/15/87	DGP: rewrote main loop to work even if the p function 		is nonmonotonic on either side of the peak.	8/30/94 dgp define INF if not already defined.*********************************************************/#include	<stdio.h>#include	"q_include.h"#define		CRITERION		1.96		/* for 95% confidence interval */#ifndef INF	#define INF (1.0/0.0)#endifdouble q_error(QCondition *qc){	double reference;	register double *p;	int nLevels;	register int i;	double questmax,gap;	int bottom=-1,top=-1;		i=vtoi(qc,q_mode(qc));	questmax=*(qc->p+i);	reference=questmax/exp(CRITERION);	// establish value below max for criterion set	nLevels=qc->nLevels;		p=qc->p;	for(i=0; i<nLevels; i++) {		if (*p++<reference) bottom=i;		else break;	}	p=qc->p+nLevels-1;	for(i=nLevels-1; i>=0; i--) {		if (*p-- < reference) top=i;		else break;	}	if (bottom==-1 || top==-1)gap=INF;	else gap=itov(qc,top-1)-itov(qc,bottom);	return gap;}